<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong Solitaire (96 Tiles, 75% Sequential, 25% Random)</title>
    <style>
        .board {
            position: relative;
            width: 620px; /* 12 cols * 50px + 10px gaps */
            height: 420px; /* 8 rows * 50px + 20px gaps */
            margin: 20px auto;
        }
        .layer {
            position: absolute;
            top: 0;
            left: 0;
        }
        .bottom-layer {
            display: grid;
            grid-template-rows: repeat(8, 50px);
            grid-template-columns: repeat(12, 50px);
            gap: 5px;
            z-index: 1;
        }
        .top-layer {
            /* Container for individually positioned tiles */
        }
        .tile {
            width: 50px;
            height: 50px;
            background-color: #f0f0f0;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        .bottom-layer .tile {
            position: relative; /* Stay within grid */
        }
        .top-layer .tile {
            position: absolute; /* Positioned over bottom layer */
            background-color: #e0e0e0; /* Slightly darker for top layer */
            z-index: 2;
        }
        .tile.selected {
            background-color: #ffff99;
        }
        .tile.removed {
            background-color: transparent;
            border: none;
            cursor: default;
            visibility: hidden;
        }
        .tile.match-hint {
            background-color: #ccffcc; /* Light green for matching free tiles */
        }
        #message, #moveCounter {
            text-align: center;
            font-family: Arial, sans-serif;
            margin-top: 10px;
        }
        #hintButton {
            display: block;
            margin: 10px auto;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <button id="hintButton">Show Hints</button>
    <div id="board" class="board">
        <div id="bottomLayer" class="layer bottom-layer"></div>
        <div id="topLayer" class="layer top-layer"></div>
    </div>
    <div id="moveCounter">Moves: 0</div>
    <div id="message"></div>
    <script>
        // Define the tile set: 48 pairs (96 tiles), 75% sequential, 25% random
        const bottomTiles = [
            "1B", "1B", "2C", "2C", "3D", "3D", "4D", "4D", "5B", "5B", "6C", "6C", // Sequential
            "7B", "7B", "8D", "8D", "9B", "9B", "1D", "1D", "2B", "2B", "3C", "3C", // Sequential
            "4B", "4B", "5D", "5D", "6D", "6D", "7C", "7C", "8B", "8B", "9C", "9C", // Sequential
            "1C", "1C", "2D", "2D", "3B", "3B", "4C", "4C", "5C", "5C", "6B", "6B", // Sequential
            "7D", "7D", "8C", "8C", "9D", "9D", "EW", "EW", "WW", "WW", "SW", "SW", // Sequential
            "NW", "NW", "RD", "RD", "GD", "GD", "1B", "1B", "2C", "2C", "3D", "3D", // Sequential
            "4D", "4D", "5B", "5B", "6C", "6C", "7B", "8D", "9B", "1D", "2B", "3C", // Sequential + Random
            "4B", "5D", "6D", "7C", "8B", "9C", "1C", "2D", "3B", "4C", "5C", "6B"  // Random
        ];

        const topTiles = [
            { tile: "7B", row: 0, col: 1 },  { tile: "8D", row: 0, col: 4 },
            { tile: "9B", row: 1, col: 7 },  { tile: "1D", row: 1, col: 10 },
            { tile: "2B", row: 2, col: 2 },  { tile: "3C", row: 2, col: 5 },
            { tile: "4B", row: 3, col: 8 },  { tile: "5D", row: 3, col: 11 },
            { tile: "6D", row: 4, col: 0 },  { tile: "7C", row: 4, col: 3 },
            { tile: "8B", row: 5, col: 6 },  { tile: "9C", row: 5, col: 9 },
            { tile: "1C", row: 6, col: 1 },  { tile: "2D", row: 6, col: 4 },
            { tile: "3B", row: 7, col: 7 },  { tile: "4C", row: 7, col: 10 }
        ];

        // Game state
        let selectedTile = null;
        let board = { bottom: [...bottomTiles], top: topTiles.map(t => t.tile) };
        let hintActive = false;
        let moveCount = 0;
        const boardElement = document.getElementById("board");
        const bottomLayerElement = document.getElementById("bottomLayer");
        const topLayerElement = document.getElementById("topLayer");
        const messageElement = document.getElementById("message");
        const moveCounterElement = document.getElementById("moveCounter");
        const hintButton = document.getElementById("hintButton");

        // Initialize the board
        function initBoard() {
            bottomLayerElement.innerHTML = "";
            topLayerElement.innerHTML = "";

            // Bottom layer (8x12 grid)
            board.bottom.forEach((tile, index) => {
                const tileElement = document.createElement("div");
                tileElement.classList.add("tile");
                tileElement.textContent = tile === null ? "" : tile;
                if (tile === null) tileElement.classList.add("removed");
                tileElement.dataset.layer = "bottom";
                tileElement.dataset.index = index;
                tileElement.addEventListener("click", () => handleTileClick("bottom", index));
                bottomLayerElement.appendChild(tileElement);
            });

            // Top layer (16 tiles spread out)
            topTiles.forEach((topTile, index) => {
                const tileElement = document.createElement("div");
                tileElement.classList.add("tile");
                tileElement.textContent = board.top[index];
                tileElement.style.top = `${topTile.row * 55}px`; // 50px height + 5px gap
                tileElement.style.left = `${topTile.col * 55}px`; // 50px width + 5px gap
                tileElement.dataset.layer = "top";
                tileElement.dataset.index = index;
                tileElement.addEventListener("click", () => handleTileClick("top", index));
                topLayerElement.appendChild(tileElement);
            });

            updateHints();
            checkGameState();
        }

        // Check if a tile is free (left or right edge, or adjacent tile removed, and not covered)
        function isTileFree(layer, index) {
            const cols = layer === "bottom" ? 12 : topTiles.length;
            const row = layer === "bottom" ? Math.floor(index / 12) : topTiles[index].row;
            const col = layer === "bottom" ? index % 12 : topTiles[index].col;

            // Check if covered by top layer (for bottom layer only)
            if (layer === "bottom") {
                for (let i = 0; i < topTiles.length; i++) {
                    if (board.top[i] !== null && topTiles[i].row === row && topTiles[i].col === col) {
                        return false;
                    }
                }
            }

            // Check left/right freedom
            const isLeftEdge = col === 0;
            const isRightEdge = col === (layer === "bottom" ? 11 : topTiles.length - 1);
            const leftIndex = index - 1;
            const rightIndex = index + 1;
            const isLeftFree = leftIndex < 0 || (leftIndex % cols < col && board[layer][leftIndex] === null);
            const isRightFree = rightIndex >= board[layer].length || (rightIndex % cols > col && board[layer][rightIndex] === null);

            // For top layer, check adjacency based on position
            if (layer === "top") {
                const currentPos = { row: topTiles[index].row, col: topTiles[index].col };
                let leftBlocked = false, rightBlocked = false;
                for (let i = 0; i < topTiles.length; i++) {
                    if (i !== index && board.top[i] !== null) {
                        const otherPos = { row: topTiles[i].row, col: topTiles[i].col };
                        if (otherPos.row === currentPos.row && otherPos.col === currentPos.col - 1) leftBlocked = true;
                        if (otherPos.row === currentPos.row && otherPos.col === currentPos.col + 1) rightBlocked = true;
                    }
                }
                return !leftBlocked || !rightBlocked;
            }

            return isLeftEdge || isRightEdge || isLeftFree || isRightFree;
        }

        // Handle tile clicks
        function handleTileClick(layer, index) {
            const tileElement = layer === "bottom" ? bottomLayerElement.children[index] : topLayerElement.children[index];
            if (board[layer][index] === null || tileElement.classList.contains("removed")) return;

            if (!isTileFree(layer, index)) {
                messageElement.textContent = "Tile is not free!";
                return;
            }

            if (selectedTile === null) {
                selectedTile = { layer, index, value: board[layer][index] };
                tileElement.classList.add("selected");
                messageElement.textContent = "Select a matching tile.";
            } else {
                const prevTileElement = selectedTile.layer === "bottom" ? bottomLayerElement.children[selectedTile.index] : topLayerElement.children[selectedTile.index];
                if (selectedTile.value === board[layer][index] && (selectedTile.layer !== layer || selectedTile.index !== index)) {
                    // Match found
                    board[selectedTile.layer][selectedTile.index] = null;
                    board[layer][index] = null;
                    prevTileElement.classList.remove("selected");
                    prevTileElement.classList.add("removed");
                    tileElement.classList.add("removed");
                    prevTileElement.textContent = "";
                    tileElement.textContent = "";
                    moveCount++;
                    moveCounterElement.textContent = `Moves: ${moveCount}`;
                    selectedTile = null;
                    messageElement.textContent = "Match made!";
                    updateHints();
                    checkGameState();
                } else {
                    // No match
                    prevTileElement.classList.remove("selected");
                    selectedTile = null;
                    messageElement.textContent = "No match. Try again.";
                }
            }
        }

        // Update hints by highlighting free tiles that have a match
        function updateHints() {
            const freeTiles = [];

            // Identify all free tiles across both layers
            for (let i = 0; i < board.bottom.length; i++) {
                if (board.bottom[i] !== null && isTileFree("bottom", i)) {
                    freeTiles.push({ layer: "bottom", index: i, value: board.bottom[i] });
                }
            }
            for (let i = 0; i < board.top.length; i++) {
                if (board.top[i] !== null && isTileFree("top", i)) {
                    freeTiles.push({ layer: "top", index: i, value: board.top[i] });
                }
            }

            // Find matching pairs among free tiles
            const matchableIndices = new Set();
            for (let i = 0; i < freeTiles.length; i++) {
                for (let j = i + 1; j < freeTiles.length; j++) {
                    if (freeTiles[i].value === freeTiles[j].value) {
                        matchableIndices.add(`${freeTiles[i].layer}-${freeTiles[i].index}`);
                        matchableIndices.add(`${freeTiles[j].layer}-${freeTiles[j].index}`);
                    }
                }
            }

            // Apply or remove hint highlighting
            const bottomTiles = bottomLayerElement.children;
            const topTiles = topLayerElement.children;
            for (let i = 0; i < board.bottom.length; i++) {
                if (board.bottom[i] !== null) {
                    const key = `bottom-${i}`;
                    bottomTiles[i].classList.toggle("match-hint", hintActive && matchableIndices.has(key));
                }
            }
            for (let i = 0; i < board.top.length; i++) {
                if (board.top[i] !== null) {
                    const key = "top-" + i;
                    topTiles[i].classList.toggle("match-hint", hintActive && matchableIndices.has(key));
                }
            }
        }

        // Check if the game is won
        function checkGameState() {
            if (board.bottom.every(tile => tile === null) && board.top.every(tile => tile === null)) {
                messageElement.textContent = "Congratulations! You won!";
            }
        }

        // Toggle hint visibility
        hintButton.addEventListener("click", () => {
            hintActive = !hintActive;
            hintButton.textContent = hintActive ? "Hide Hints" : "Show Hints";
            updateHints();
        });

        // Start the game
        initBoard();
    </script>
</body>
</html>
